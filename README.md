# yandexCalculator
Распределенный вычислитель арифметических выражений
Разработал - Антонов Денис (телеграм для связи и вопросов [@semyadmin](https://t.me/semyadmin))

<details>
    <summary>Описание задачи: </summary>
    Пользователь хочет считать арифметические выражения. Он вводит строку 2 + 2 * 2 и хочет получить в ответ 6. Но наши операции сложения и умножения (также деления и вычитания) выполняются "очень-очень" долго. Поэтому вариант, при котором пользователь делает http-запрос и получает в качетсве ответа результат, невозможна. Более того: вычисление каждой такой операции в нашей "альтернативной реальности" занимает "гигантские" вычислительные мощности. Соответственно, каждое действие мы должны уметь выполнять отдельно и масштабировать эту систему можем добавлением вычислительных мощностей в нашу систему в виде новых "машин". Поэтому пользователь, присылая выражение, получает в ответ идентификатор выражения и может с какой-то периодичностью уточнять у сервера "не посчиталость ли выражение"? Если выражение наконец будет вычислено - то он получит результат. Помните, что некоторые части арфиметического выражения можно вычислять параллельно.

    Front-end часть

    GUI, который можно представить как 4 страницы

        Форма ввода арифметического выражения. Пользователь вводит арифметическое выражение и отправляет POST http-запрос с этим выражением на back-end. Примечание: Запросы должны быть идемпотентными. К запросам добавляется уникальный идентификатор. Если пользователь отправляет запрос с идентификатором, который уже отправлялся и был принят к обработке - ответ 200. Возможные варианты ответа:
            200. Выражение успешно принято, распаршено и принято к обработке
            400. Выражение невалидно
            500. Что-то не так на back-end. В качестве ответа нужно возвращать id принятного к выполнению выражения.
        Страница со списком выражений в виде списка с выражениями. Каждая запись на странице содержит статус, выражение, дату его создания и дату заверщения вычисления. Страница получает данные GET http-запрсом с back-end-а
        Страница со списком операций в виде пар: имя операции + время его выполнения (доступное для редактирования поле). Как уже оговаривалось в условии задачи, наши операции выполняются "как будто бы очень долго". Страница получает данные GET http-запрсом с back-end-а. Пользователь может настроить время выполения операции и сохранить изменения.
        Страница со списком вычислительных можностей. Страница получает данные GET http-запросом с сервера в виде пар: имя вычислительного ресурса + выполняемая на нём операция.

        Требования:
        Оркестратор может перезапускаться без потери состояния. Все выражения храним в СУБД.
        Оркестратор должен отслеживать задачи, которые выполняются слишком долго (вычислитель тоже может уйти со связи) и делать их повторно доступными для вычислений.


    Back-end часть

    Состоит из 2 элементов:

        Сервер, который принимает арифметическое выражение, переводит его в набор последовательных задач и обеспечивает порядок их выполнения. Далее будем называть его оркестратором.
        Вычислитель, который может получить от оркестратора задачу, выполнить его и вернуть серверу результат. Далее будем называть его агентом.

    Оркестратор
    Сервер, который имеет следующие endpoint-ы:

        Добавление вычисления арифметического выражения.
        Получение списка выражений со статусами.
        Получение значения выражения по его идентификатору.
        Получение списка доступных операций со временем их выполения.
        Получение задачи для выполения.
        Приём результата обработки данных.


    Агент
    Демон, который получает выражение для вычисления с сервера, вычисляет его и отправляет на сервер результат выражения. При старте демон запускает несколько горутин, каждая из которых выступает в роли независимого вычислителя. Количество горутин регулируется переменной среды.
</details>

# Краткое описание программы

 Данная программа представляет собой вычислитель арифметических операций (плюс, минус, умножить и делить), которые выполняются, по  возможности, параллельно. Прежде всего, выполняется запуска данного приложения (запуск описывается ниже). Потом, пользователь регистрируется под своей учетной записью (регистрация проходит автоматически, если такого имени пользователя не было) или заходит под своим логином и паролем. Если такой пользователь уже есть и пароли не совпадают - возникнет ошибка. Надо или ввести другое имя или ввести пароль, который > уже был для этого пользователя. Восстановление или сброс паролей не предусмотренны текущей версией программы.
 После входа, пользователь вводит выражение для подсчета - например:

    2+2

 После этого, оркестратор проверит корректность выражения и начнет вычислять, если оно корректное. Для этого в само выражение добавляются дополнительные скобки (если возможно) и выражение преобразуется в AST дерево и каждая операция помещается в очередь для того, что бы агент (или агенты) забрал ее для вычисления с текущими параметрами длительности, которые установил пользователь или, которые установлены по умолчанию (длительность операций по умолчанию - 0 минут для всех - то есть мгновенно). После того, как агент забрал и подсчитал выражение, он возвращает результат подсчета и ошибку, если операцию не удалось вычислить. После вычисления всех операций, оркестратор по web socket (если соединение было установлено) отсылает результат вычислений пользователю. Или пользователь сам может узнать результаты вычисления выражения. У каждого пользователя свои уникальные выражения (например, у пользователя 1 есть выражение "1+1" и у пользователя 2 есть выражение "1+1" - они разные. Если у пользователя 1 есть выражение "1+1", то, если будет еще одна такая операция, то вернется результат прошлого выражения "1+1").


Запуск оркестратора и агента (агентов) можно выполнить несколькими способами

### 1. Простой способ с использование докер файлов.

Нужно, что бы у вас был установлен docker. Можно поставить его по инструкциям

https://docs.docker.com/engine/install/


Если установлен git

    git clone https://github.com/adminsemy/yandexCalculator

Если git не установлен
Качаем архив по ссылке 

https://github.com/adminsemy/yandexCalculator/archive/refs/heads/main.zip

и раcпаковываем в любую папку.

Далее переходим в коревую папку и запускаем команду.

    docker compose up

или 

    docker-compose up

>ВНИМАНИЕ - порты 8080, 7777 и 5432 должны быть не заняты!
Если они заняты и нужны, то надо зайти в папку Orchestrator/config и в файле .env изменить на нужные а так же в файле docker-compose.yaml. Если меняется ORCHESTRATOR_TCP_PORT, то соответствующую настройку необходимо сделать в агенте (из корневой папки папка Agent/config и отредактировать параметр PORT))

После запуска контейнеров можно перейти по адресу (если не менялся ORCHESTRATOR_HTTP_PORT)

http://localhost:8080/

### 2. Второй способ без установки докера

Так же делаем клон репозитория или качаем архив. Затем переходим в папку Orchestrator. В этой папке надо поменять настройки для запуска оркестратора, если используются другие адреса: 
>В папке config меняем в файле .env ORCHESTRATOR_DB  на вашу базу данных. База данных используется PostgreSQL

Потом запускаем проект  командой

    go run cmd/orchestrator/main.go


Возвращаемся в корневую папку, потом переходим в папку Agent и из этой папки запустить агент командой

    go run cmd/agent/main.go

Запуск базы данных будет возложен на вас. Хочу отметить, что проект может корректно работать без базы данных. Для корректной работы базы надо запустить (или выполнить запрос) в запущенной PostgreSQL файл yandex.sql из папки sql коревого каталога проекта. База данных должна называться orchestrator. Или вы можете поменять имя в настройках оркестратора в файле .env на любое другое.

### 3. Третьий способ с компиляцией

Клонируем себе репозиторий по описанной выше схеме. Далее переходим в папки Orchestrator и Agent как в способе 2, только запускаем команды для Orchestrator

    go build cmd/orchestrator/main.go

и запускаем получившийся в директории файл main (в версии Windows файл будет main.exe)

Для Agent

    go build cmd/agent/main.go

и запускаем получившийся в директории файл main (в версии Windows файл будет main.exe)

### Настройки оркестратора

Все настройки находятся в файле ./Orchestrator/config/.env и для докер образа в файле docker-compose.yaml.

- ORCHESTRATOR_HTTP_PORT - настройка HTTP порта для работы сервера по протоколу http.
- ORCHESTRATOR_TCP_PORT - настройка для работы TCP сервера. TCP сервер нужен для работы с агентом по gRPC.
- ORCHESTRATOR_DB - адрес базы данных.
- ORCHESTRATOR_DB_NAME - название базы данных.
- ORCHESTRATOR_DB_PORT - порт для подключения к базе данных.
- ORCHESTRATOR_DB_USER - имя пользователя для базы данных.
- ORCHESTRATOR_DB__PASSWORD - пароль для базы данных.
- ORCHESTRATOR_TOKEN_LIMIT - время жизни токена. Измеряется в минутах

### Настройки агента

Все настройки находятся в файле ./Agent/config/.env и для докер образа в файле docker-compose.yaml.
- HOST - имя или IP адрес для оркестратора.
- PORT - порт оркестратора.
- MAX_GOROUTINES_AGENT - количество горутин у агента.

# Описание API оркестратора

Можно использовать curl, Postman или что-нибудь еще для отправки данных да оркестратор. Так же используется визуальное отображение через веб-браузер.

>Для доступа ко многим API нужно добавлять корректный токен в заголовки запроса (в заголовок Authorization: Bearer <ваш_токен>). Такие запросы подписаны "С авторизацией"

Используются следующие API:

- "/" - любой запрос вернет html файл сгенерированных для подключения к оркестратору. Без авторизации

- "/api/v1/auth" - метод POST принимает JSON вида

```js
{    
    login: "login",
    password: "password"
}
```

- В ответ отдает токен строкового параметра в теле ответа, если это новый пользователь или если password совпадают с предыдущими значение password для login. Имена пользователей и пароли хранятся в базе (пароли в зашифрованном виде)

- "/duration" - метол POST устанавливает нужное время (в секундах) для каждой арифметической операции для каждого пользователя. Если данные неверные - вернет текст ошибки и статус 400.  Метод GET вернет текущие настройки времени. Если настроек нет - вернет значения по умолчанию. С авторизацией. 
Для POST ожидается и возвращается JSON следующего вида

```js
{    
    plus: 0,
    minus: 0,
    multiply: 0,
    divide: 0
}
```

- "/expression" - метод POST принимает нужное выражение строковым параметром вида text/plan. Поддерживаются операции "+", "-", "*", "/", а так же скобки "(" и ")". Все пробелы игнорируются (удаляются). Если выражение корректное - начнется высчитываться выражение и вернет выражение с его ID, датой его создания, датой завершения и его текущий статус. Если некорректное - вернет тоже самое выражение, но со статусом error. Если написать выражение, которое уже было, то вернется это выражение, его ID и статус. С авторизацией. Возвращается следующий JSON

```js
{    
    ID: "1",
	Expression: "2+2",
	Start:  "31.12.2000 15:13:59",
	End: "31.12.2000 15:13:59"
	Status: "progress"
}
```

- Статусы бывают следующих видов:
    - "progress" - выражение находится на стадии вычисления
    - "completed" - выражение вычислено, есть результат
    - "error" - произошла ошибка при вычислении или выражение было изначально некорректное

- "/getexpressions" - метод GET возвращает все выражения, которые пользователь ввел ранее. Если выражений нет - вернет пустой список. С авторизацией. Результат возвращается в виде JSON следующего формата

```js
[
    {    
        ID: "1",
        Expression: "2+2",
        Start:  "31.12.2000 15:13:59",
        End: "31.12.2000 15:13:59"
        Status: "progress"
    },
    {
        ID: "2",
        Expression: "3+3=6",
        Start:  "31.12.2000 15:15:59",
        End: "31.12.2000 15:15:59"
        Status: "comlited"
    },
    ....
]
```

- Возможные статусы такие же, как в "/getexpressions"


- "/id/{id}" - метод POST принимает ID выражения и возвращает его, если оно найдено. Если нет - возвращается статс 400 и ошибка. Резльтат в виде JSON объекта описанного в API "/getexpressions". С авторизацией.

"/workers" - (пока данные по агентам и воркерам не отдает ввиду перевода общения оркестратора с агентами на gRPC вместо TCP/IP) по методу GET возвращает количество запущенных агентов, общее количество горутин всех агентов, занятых горутин (ворекров), которые обрабатывают текущую операцию и массив обрабатываемых на данный момент операций. Без авторизации. Возвращает JSON вида

```javascript
{
    agents: 0,
	workers: 0,
	workersBusy: 0,
	expressions:  [
        "2+2",
        "3+3",
        ...
        "1+1"
    ]
}
```

- "/ws" - принимает запрос на создание webSocket для передачи данных о состоянии текущих выражений.С авторизацией. Токен необходимо добавить в параметры запроса - например:

      ws://localhost:8080/ws?token=<ваш_токен>


# Как тестировать программу

Реализовано несколько unit тестов (не для всех объектов). Можно запустить команду в папках Orchestrator и Agent

    go test ./... -cover


Интеграционные тесты пока не реализованы

Так же можно отсылать выражения на определенные API (описаны выше) через curl, Postman и прочие подобные программы. Но для начала необходимо получить токен, залогинившись по пути "/api/v1/auth". Далее будет описан принцип работы программы с использованием веб интерфейса, которое прилагается к программе, написанное на React JS + MaterialUI + axios

# Принцип работы программы

Прежде всего переходим по пути 

    http://localhost:8080

Сразу же нас попросят ввести логин и пароль. Вводим любой логин и пароль - поля должны быть заполнены. Если такого логина в системе раньше не было, то создается новый пользователь с таким логином и при последующих аутентификациях будут сравниваться хеши паролей сохраненный с отправленным

![Вход](/MDImages/01.png)

Далее можно настроить время для подсчета каждой операции. Для этого, надо перейти во вкладку "Установить продолжительность"

![Вход](/MDImages/02.png)

Устанавливаем необходимое нам время и нажимаем кнопку отправить. При успешной отправке данных выплывет зеленое окошко говорящее о том, что данные успешно загружены или красное, говорящее о возникших проблемах. 

После установки необходимого (если нужно) времени, можно отправлять выражение.Для этого по вкладке "Расчитать выражение" вводим нужное нам выражения для подсчета и нажимаем кнопку "Расчитать". Введенная строка будет отправлена на сервер и выведена в таблицу на странице, что бы следить за ее состоянием. Состояние меняется АВТОМАТИЧЕСКИ - перезагружать страницу не надо! У выражения есть несколько состояний
- выражение подсчитано. Напротив выражения есть галочка и есть результать  выражения
- выражение в процессе вычисления. Выражение еще вычисляется. Рядом с ним есть значок загрузки
- выражение ошибочно. Неверное введеное выражение или в процессе вычисления возникла ошибка подсчета

![Вход](/MDImages/03.png)

### Примеры для тестирования выражений

- 2+2 = 4
- 9*9 = 81
- 9+--9/* = error
- -2+-2+3*99-100+6/3*(81+9*78-63) = 1663
- -2+9*81+9*(2-2)*(1-3) = 727

Через определенное время (по умолчанию 15 минут) токен перестанет быть валидным и нужно будет заново зайти в систему. Так же, при заходе в систему, если пользователь ранее был зарегистрирован и вводил продолжительность или выражения, то все данные будут вновь подгружены. Если есть база данных, то данные подгрузяться автоматически при перезапуске программы. Если нет, то все данные будут утеряны

### Как происходит Подсчет выражения

Пользователь вводит выражение. Оркестратор принимает выражение,валидирует его и, если валидация проходит, создает AST дерево, разбивая выражение на операции. Затем выражение сохраняется в мапе (если есть соединения с базой данных - выражение сохраняется в базу) и запускается вычисление выражения. Каждая отдельная операция ставится в очередь по порядку добавления и ждет, когда агент попросит данных. Когда воркер агента подключается к оркестратору через gRPC, запрашивая данные, данные извлекаются из очереди по порядку, записываются в мапу очереди и отправляются агенту для вычисления. После вычисления, агнет возвращает результат операции или ошибку, если операцию не удалось посчитать. Оркестратор принимает операцию, сообщает выражению результат вычисления и сохраняет в мапу вычисленных операций ее состояние. Так же в отдельную мапу сохраняется выражение с подсчитанной операцией для сохранения в базу данных (сохраняется каждую секунду). Дальше все повторяется до тех пор, пока выражение не будет посчитано полностью. Полностью подсчитанное выражение остается в мапе сохраненных выражений.

#### На данный момент

Весь реализованный ранее функционал работает как раньше, только в контексте конкретного пользователя. - работает

У кого выражения хранились в памяти - переводим хранение в SQLite. (теперь наша система обязана переживать перезагрузку) - реализован PostgreSQL

У кого общение вычислителя и сервера вычислений было реализовано с помощью HTTP - переводим взаимодействие на GRPC - реализовано

покрытие проекта модульными тестами - частично реализовано

покрытие проекта интеграционными тестами - не реализовано (времени не хватило)

# Схема работы

![Схема работы](/MDImages/schemeYandexCalculator.png)
